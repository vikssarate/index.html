<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>MyTechStudy • PDF Viewer</title>
<style>
  :root{--ui:rgba(0,0,0,.55);--ink:#fff}
  html,body{height:100%;margin:0;background:#0b0f18;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  /* top bar */
  #topbar{
    position:fixed;inset:0 0 auto 0;display:flex;gap:8px;align-items:center;padding:8px 12px;
    background:linear-gradient(to bottom,rgba(0,0,0,.55),rgba(0,0,0,0));z-index:5;user-select:none
  }
  .btn{border:1px solid rgba(255,255,255,.2);background:var(--ui);color:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer;backdrop-filter:blur(6px)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .grow{flex:1}

  /* scrolling area */
  #viewer{
    position:fixed;inset:0; padding-top:60px; overflow:auto; -webkit-overflow-scrolling:touch;
  }

  /* each page container: block layout + real margins to avoid overlap */
  .page{
    display:block;
    width:min(100%,1000px);
    margin:12px auto; /* real margin so pages never touch */
    background:#111827;border-radius:12px;overflow:hidden;
    border:1px solid rgba(255,255,255,.07);
    box-shadow:0 6px 24px rgba(0,0,0,.35);
    position:relative;
    min-height:220px; /* replaced with correct height before render */
  }
  .ph{color:#9ab;font-size:12px;position:absolute;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100%;height:auto}
</style>
</head>
<body>

<div id="topbar">
  <button id="zoomOut" class="btn" title="Zoom out">−</button>
  <button id="zoomIn"  class="btn" title="Zoom in">+</button>
  <div class="grow"></div>
  <span class="btn" style="pointer-events:none">Page <b id="cur">1</b> / <b id="tot">…</b> • <span id="scaleLbl">100%</span></span>
  <a id="download" class="btn" download>Download</a>
</div>

<div id="viewer"></div>

<!-- PDF.js -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script>
(() => {
  // --------- PDF source ----------
  const q = new URL(location.href).searchParams;
  const PDF_URL = q.get('file') || 'https://files.mytechstudy.in/PDN_HANDBOOK_VOLLUME_I.pdf'; // your default
  // Fast streaming with range requests
  const params = {
    url: PDF_URL,
    rangeChunkSize: 262144,   // 256 KB chunks (good balance)
    disableStream: false,
    disableAutoFetch: true    // only fetch what we view
  };
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

  // UI refs
  const viewer   = document.getElementById('viewer');
  const zoomIn   = document.getElementById('zoomIn');
  const zoomOut  = document.getElementById('zoomOut');
  const curEl    = document.getElementById('cur');
  const totEl    = document.getElementById('tot');
  const scaleLbl = document.getElementById('scaleLbl');
  const dl       = document.getElementById('download');
  dl.href = PDF_URL;

  // State
  let pdf = null;
  let scale = 1.0;
  const DPR = Math.min(2, window.devicePixelRatio || 1); // keep memory sane
  let pages = [];               // {el, num, rendered}
  let rendering = new Set();
  let aspect = 1.414;           // default A-series ratio fallback (≈√2)

  // Load
  pdfjsLib.getDocument(params).promise.then(async (_pdf) => {
    pdf = _pdf;
    totEl.textContent = pdf.numPages;

    // Compute base scale (fit width) + aspect ratio from page 1
    const p1   = await pdf.getPage(1);
    const vp1  = p1.getViewport({ scale: 1 });
    aspect     = vp1.height / vp1.width;
    const contW = Math.min(viewer.clientWidth - 24, 1000); // same as .page width minus margins
    scale = contW / vp1.width;
    scaleLbl.textContent = Math.round(scale * 100) + '%';

    // Build all placeholders with real height so layout never collapses/overlaps
    for (let i = 1; i <= pdf.numPages; i++) {
      const el = document.createElement('div');
      el.className = 'page'; el.id = 'p' + i;
      // reserve height using aspect * current width
      const w = Math.min(viewer.clientWidth - 24, 1000);
      el.style.minHeight = Math.round(w * aspect * scale) + 'px';

      const ph = document.createElement('div');
      ph.className = 'ph';
      ph.textContent = `Page ${i}`;
      el.appendChild(ph);
      viewer.appendChild(el);
      pages.push({ el, num: i, rendered: false, canvas: null });
    }

    // IntersectionObserver: lazy render near viewport
    const io = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          const idx = parseInt(e.target.id.slice(1), 10) - 1;
          render(idx);
          // also prefetch neighbors for smooth scrolling
          for (let j = 1; j <= 2; j++) {
            if (idx + j < pages.length) render(idx + j);
          }
        }
      });
    }, { root: viewer, rootMargin: '800px 0px', threshold: 0.01 });

    pages.forEach(p => io.observe(p.el));
    render(0);
    viewer.addEventListener('scroll', updateCurrent, { passive: true });
    updateCurrent();
  }).catch(err => {
    console.error(err);
    viewer.innerHTML = '<div style="padding:24px;color:#faa">Failed to load PDF. Check CORS/public access and the URL.</div>';
  });

  async function render(idx){
    const p = pages[idx];
    if (!pdf || p.rendered || rendering.has(idx)) return;
    rendering.add(idx);
    try {
      const page = await pdf.getPage(p.num);
      const vp   = page.getViewport({ scale });
      const c    = document.createElement('canvas');
      const ctx  = c.getContext('2d');

      // device-pixel sharp
      c.width  = Math.floor(vp.width  * DPR);
      c.height = Math.floor(vp.height * DPR);
      c.style.width  = Math.floor(vp.width) + 'px';
      c.style.height = Math.floor(vp.height) + 'px';

      await page.render({
        canvasContext: ctx,
        viewport: vp,
        transform: [DPR, 0, 0, DPR, 0, 0]
      }).promise;

      p.el.innerHTML = '';          // remove placeholder
      p.el.appendChild(c);
      p.canvas   = c;
      p.rendered = true;

      // lock exact height to the rendered canvas to avoid later reflow
      p.el.style.minHeight = c.style.height;
    } catch(e){
      console.error('Render error', idx+1, e);
    } finally {
      rendering.delete(idx);
    }
  }

  function updateCurrent(){
    const mid = viewer.scrollTop + viewer.clientHeight/2;
    let best = 0, bestD = Infinity;
    for (let i=0;i<pages.length;i++){
      const r = pages[i].el;
      const center = r.offsetTop + r.offsetHeight/2;
      const d = Math.abs(center - mid);
      if (d < bestD){ bestD = d; best = i; }
    }
    curEl.textContent = best + 1;
  }

  // Zoom: re-reserve heights and mark pages dirty (will re-render when in view)
  function rerenderAll(){
    pages.forEach(p=>{
      if (p.rendered){
        p.rendered = false;
        p.el.innerHTML = `<div class="ph">Page ${p.num}</div>`;
        p.canvas = null;
      }
      // recompute reserved height based on new scale
      const w = Math.min(viewer.clientWidth - 24, 1000);
      p.el.style.minHeight = Math.round(w * aspect * scale) + 'px';
    });
    // kick current + neighbors
    const y = viewer.scrollTop;
    const mid = y + viewer.clientHeight/2;
    let start = 0;
    for (let i=0;i<pages.length;i++){
      if (pages[i].el.offsetTop + pages[i].el.offsetHeight/2 > mid){ start = Math.max(0,i-2); break; }
    }
    for (let i=start; i<Math.min(start+6, pages.length); i++) render(i);
    scaleLbl.textContent = Math.round(scale*100) + '%';
  }
  zoomIn.onclick  = () => { scale = Math.min(scale*1.2, 5);    rerenderAll(); };
  zoomOut.onclick = () => { scale = Math.max(scale/1.2, 0.25); rerenderAll(); };

  // Resize: keep “fit width” base and preserve relative zoom
  let rt=null;
  addEventListener('resize', () => {
    if (!pages.length) return;
    clearTimeout(rt);
    rt = setTimeout(() => {
      const w = Math.min(viewer.clientWidth - 24, 1000);
      const fit = w / (w / scale); // keep same scale relative to current width
      // recompute scale to fit new width proportionally
      const oldW = parseFloat(pages[0].el.style.minHeight) / (aspect*scale) || w;
      const rel  = scale / (oldW / (oldW/scale));
      scale = (w / (w/scale)) * rel;
      // simpler: refit strictly
      scale = w / (w / scale);
      rerenderAll();
    }, 150);
  }, { passive:true });
})();
</script>
</body>
</html>
